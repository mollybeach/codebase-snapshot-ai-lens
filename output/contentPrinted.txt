

=== File: ../../branch/app-brkt-v2/.eslintrc.json ===
{
  "extends": "next/core-web-vitals"
}



=== File: ../../branch/app-brkt-v2/.firebaserc ===
{
  "projects": {
    "default": "brkt-app"
  }
}



=== File: ../../branch/app-brkt-v2/README.md ===
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.



=== File: ../../branch/app-brkt-v2/components.json ===
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}



=== File: ../../branch/app-brkt-v2/firebase.json ===
{
  "firestore": {
    "indexes": "firestore.indexes.json"
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint",
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ]
}


=== File: ../../branch/app-brkt-v2/firebase.ts ===
// firebase.ts
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import { getMessaging, getToken, onMessage } from "firebase/messaging";
import { getFunctions, httpsCallable } from "firebase/functions";
import { 
  getAnalytics, 
  logEvent, 
  setUserProperties,
  type Analytics,
  type AnalyticsCallOptions
} from "firebase/analytics";

const firebaseConfig = {
  apiKey: "AIzaSyBF6zSQQowt2d2XheqfKy-b1X3ULDjOOXE",
  authDomain: "hookt.app",
  projectId: "brkt-app",
  storageBucket: "brkt-app.appspot.com",
  messagingSenderId: "815513528903",
  appId: "1:815513528903:web:106602a610a74161a05f62"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const firestore = getFirestore(app);
const storage = getStorage(app);
const functions = getFunctions(app, "us-central1");

export const analytics: Analytics | null =
  typeof window !== "undefined" ? getAnalytics(app) : null;

// Helper function to safely log events with proper typing
export const logAnalyticsEvent = (
  eventName: string,
  eventParams?: { [key: string]: any }
) => {
  if (analytics) {
    logEvent(analytics, eventName, eventParams);
  }
};

// Helper function to safely set user properties with proper typing
export const setAnalyticsUserProperties = (
  properties: { [key: string]: any }
) => {
  if (analytics) {
    setUserProperties(analytics, properties);
  }
};


// Only initialize messaging on the client side.
export const messaging =
  typeof window !== "undefined" && "serviceWorker" in navigator
    ? getMessaging(app)
    : null;

// Initialize Firebase Messaging and get a token.
const initializeFirebaseMessaging = async (retryCount = 0): Promise<string | null> => {
    if (!messaging || typeof window === "undefined" || !("serviceWorker" in navigator)) {
      return null;
    }
  
    try {
      const vapidKey = process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY;
      if (!vapidKey) {
        throw new Error("Missing NEXT_PUBLIC_FIREBASE_VAPID_KEY in environment.");
      }
  
      // Get the Firebase Messaging service worker registration specifically
      let messagingRegistration = await navigator.serviceWorker.getRegistration('/firebase-cloud-messaging-push-scope/');
      
      // If no messaging service worker exists or if it needs updating, register it
      if (!messagingRegistration) {
        console.log("Registering Firebase Messaging service worker...");
        messagingRegistration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', {
          scope: '/firebase-cloud-messaging-push-scope/'
        });
      }
  
      // Wait for activation if needed
      if (messagingRegistration.installing || messagingRegistration.waiting) {
        await new Promise<void>((resolve) => {
          messagingRegistration.addEventListener('activate', () => resolve(), { once: true });
        });
      }
  
      // Check notification permission
      if (Notification.permission === "granted") {
        try {
          // Get existing token or generate new one using the messaging registration
          const token = await getToken(messaging, {
            vapidKey,
            serviceWorkerRegistration: messagingRegistration
          });
          
          if (token) {
            console.log("FCM token available");
            return token;
          }
        } catch (error) {
          console.error("Error getting token:", error);
          if (retryCount < 3) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return initializeFirebaseMessaging(retryCount + 1);
          }
          throw error;
        }
      } else {
        console.log("Requesting notification permission...");
        const permission = await Notification.requestPermission();
        if (permission === "granted") {
          return initializeFirebaseMessaging(retryCount);
        }
      }
      return null;
    } catch (error) {
      console.error("Error in initializeFirebaseMessaging:", error);
      if (retryCount < 3) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return initializeFirebaseMessaging(retryCount + 1);
      }
      throw error;
    }
  };
  
// Only set up messaging on the client side.
if (typeof window !== "undefined" && messaging) {
  // Initialize messaging when the app loads.
  initializeFirebaseMessaging().catch(console.error);

  // Set up foreground message handler.
  onMessage(messaging, (payload) => {
    // Only show notification if tab isn't visible
    if (document.visibilityState !== 'visible' && payload.notification) {
      // Don't show notification - let service worker handle it
      console.log('Received foreground message but letting service worker handle it:', payload);
      return;
    }
    // Log but don't show notification when tab is visible
    console.log('Received foreground message:', payload);
  });
}


export const sendTestFCMNotification = async () => {
    if (!messaging || typeof window === "undefined") {
      console.error("Messaging is not available");
      return;
    }
    try {
      const testNotification = httpsCallable(functions, "sendNotification");
      const token = await getToken(messaging);
      if (!token) {
        console.error("No FCM token available");
        return;
      }
      const result = await testNotification({
        token,
        data: {
          type: "test",
          url: "/",
          title: "FCM Test Notification", 
          body: "Testing FCM notification delivery"
        },
        webpush: {
          headers: {
            Urgency: "normal",
            TTL: "86400"
          },
          notification: {
            title: "FCM Test Notification",
            body: "Testing FCM notification delivery",
            requireInteraction: true,
            icon: '/icon-192x192.png',
            badge: '/badge-72x72.png',
            tag: 'test_notification',
            data: {
              url: "/"
            }
          },
          fcm_options: {
            link: "/"
          }
        }
      });
      console.log("Test notification sent:", result);
    } catch (error) {
      console.error("Error sending test notification:", error);
    }
  };
  
export { auth, firestore, storage, functions };



=== File: ../../branch/app-brkt-v2/firestore.indexes.json ===
{
    "indexes": [
      {
        "collectionGroup": "settings",
        "queryScope": "COLLECTION_GROUP",
        "fields": [
          {
            "fieldPath": "preferences.newMarkets",
            "order": "ASCENDING"
          },
          {
            "fieldPath": "__name__",
            "order": "ASCENDING"
          }
        ]
      },
        {
        "collectionGroup": "tokens",
        "queryScope": "COLLECTION_GROUP",
        "fields": [
          {
            "fieldPath": "userId",
            "order": "ASCENDING"
          },
          {
            "fieldPath": "__name__",
            "order": "ASCENDING"
          }
        ]
      },
  
      {
        "collectionGroup": "votes",
        "queryScope": "COLLECTION_GROUP",
        "fields": [
          {
            "fieldPath": "competitionId",
            "order": "ASCENDING"
          },
          {
            "fieldPath": "__name__",
            "order": "ASCENDING"
          }
        ]
      }
    ],
    "fieldOverrides": []
  }
  


=== File: ../../branch/app-brkt-v2/manifest.json ===
{
    "name": "Hookt",
    "short_name": "Hookt",
    "description": "Bet on relevant topics",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#1B1B1B",
    "theme_color": "#1B1B1B",
    "orientation": "portrait",
    "icons": [
      {
        "src": "/icon-192x192.png",
        "sizes": "192x192",
        "type": "image/png",
        "purpose": "any maskable"
      },
      {
        "src": "/icon-512x512.png",
        "sizes": "512x512",
        "type": "image/png",
        "purpose": "any maskable"
      }
    ],
    "gcm_sender_id": "815513528903"
  }


=== File: ../../branch/app-brkt-v2/postcss.config.mjs ===
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;



=== Directory: ../../branch/app-brkt-v2/functions ===


=== File: ../../branch/app-brkt-v2/functions/.eslintrc.js ===
module.exports = {
  root: true, 
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json", "tsconfig.dev.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*",
    "/generated/**/*",
  ],
  plugins: [
    "@typescript-eslint"
  ],
  rules: {
    "quotes": ["error", "double"],
    "indent": ["error", 2],
  },
};


=== File: ../../branch/app-brkt-v2/functions/tsconfig.dev.json ===
{
  "include": [
    ".eslintrc.js"
  ]
}



=== Directory: ../../branch/app-brkt-v2/functions/src ===


=== File: ../../branch/app-brkt-v2/functions/src/index.ts ===
import { onSchedule } from "firebase-functions/v2/scheduler";
import * as admin from "firebase-admin";

if (!admin.apps.length) {
  admin.initializeApp();
}

interface PendingVoteRecord {
  userId: string;
  competitionId: string;
  competitionAddress: string;
  prediction: number;
  transactionHash?: string;
  userOpHash?: string;
  timestamp: admin.firestore.Timestamp;
  status:
    | "pending"
    | "processing"
    | "confirmed"
    | "completed"
    | "failed"
    | "maxAttemptsReached"
    | "verification_failed";
  error?: string;
  attempts: number;
  leverageMultiplier?: number;
  lastAttempt?: admin.firestore.Timestamp;
  lastChecked?: admin.firestore.Timestamp;
  completedAt?: admin.firestore.Timestamp;
  failedAt?: admin.firestore.Timestamp;
  maxAttemptsReachedAt?: admin.firestore.Timestamp;
  verificationFailedAt?: admin.firestore.Timestamp;
}

// Collections and constants
const PENDING_VOTES_COLLECTION = "pendingVotes";
const CRITICAL_FAILURES_COLLECTION = "criticalFailures";
const MAX_RECOVERY_ATTEMPTS = 5;
const BATCH_SIZE = 100; // How many documents to process per "page"
const BUNDLER_URL =
  process.env.BUNDLER_URL ||
  "https://bundler.biconomy.io/api/v2/8453/0192f7c6-6152-732f-8e6a-3c138662ec86";

// ---------------------
// HELPER: Verify if a vote is properly recorded
// ---------------------
const verifyVoteRecorded = async (
  db: admin.firestore.Firestore,
  userId: string,
  competitionId: string,
  prediction: number,
  transactionHash: string
): Promise<boolean> => {
  try {
    // Check main vote record
    const userVoteRef = db.doc(`users/${userId}/votes/${competitionId}`);
    const voteDoc = await userVoteRef.get();

    if (!voteDoc.exists) {
      console.log("Main vote record not found");
      return false;
    }

    const voteData = voteDoc.data();
    if (
      voteData?.transactionHash !== transactionHash ||
      voteData?.status !== "completed"
    ) {
      console.log("Transaction hash mismatch or status not completed", {
        expectedHash: transactionHash,
        actualHash: voteData?.transactionHash,
        status: voteData?.status,
      });
      return false;
    }

    // Check competition votes
    const competitionRef = db.doc(`competitions/${competitionId}`);
    const competitionDoc = await competitionRef.get();
    if (!competitionDoc.exists) {
      console.log("Competition not found");
      return false;
    }

    const voteTypeRef = db.doc(
      `competitions/${competitionId}/${
        prediction === 1 ? "yesVotes" : "noVotes"
      }/${userId}`
    );

    const competitionVoteDoc = await voteTypeRef.get();
    if (!competitionVoteDoc.exists) {
      console.log("Competition vote document not found");
      return false;
    }

    // Verify competition total count
    const competitionData = competitionDoc.data();
    const expectedField = prediction === 1 ? "yesVotes" : "noVotes";
    const voteCount = competitionData?.[expectedField] || 0;

    if (voteCount === 0) {
      console.log("Vote count is 0 but vote document exists");
      return false;
    }

    console.log("Vote verification passed all checks");
    return true;
  } catch (error) {
    console.error("Vote verification failed with error:", error);
    return false;
  }
};

// ---------------------
// HELPER: Check receipt from bundler
// ---------------------
async function checkUserOpReceipt(userOpHash: string): Promise<any> {
  if (!BUNDLER_URL) {
    console.error("No bundler URL configured");
    return null;
  }

  try {
    console.log("Using bundler URL:", BUNDLER_URL);
    console.log("Checking receipt for userOpHash:", userOpHash);

    const response = await fetch(BUNDLER_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_getUserOperationReceipt",
        id: Date.now(),
        params: [userOpHash],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("HTTP error from bundler:", {
        status: response.status,
        statusText: response.statusText,
        body: errorText,
      });
      throw new Error(
        `HTTP error! status: ${response.status}, body: ${errorText}`
      );
    }

    const data = await response.json();
    console.log("Receipt response data:", JSON.stringify(data, null, 2));

    if (data.error) {
      console.error("RPC error from bundler:", data.error);
      throw new Error(`RPC error: ${JSON.stringify(data.error)}`);
    }

    if (!data.result) {
      console.log("No receipt found yet, null result is normal while waiting");
    } else {
      console.log("Receipt found:", JSON.stringify(data.result, null, 2));
    }

    return data.result;
  } catch (error) {
    console.error("Error checking receipt:", {
      error: error instanceof Error ? error.message : "Unknown error",
      userOpHash,
      bundlerUrl: BUNDLER_URL,
    });
    return null;
  }
}

// ---------------------
// HELPER: Handle votes that reached max attempts
// ---------------------
async function handleMaxAttemptsReached(
  db: admin.firestore.Firestore,
  voteDoc: admin.firestore.QueryDocumentSnapshot,
  voteData: PendingVoteRecord,
  error: any
): Promise<void> {
  console.log(`Handling vote ${voteDoc.id} that reached max attempts`);

  try {
    const now = admin.firestore.Timestamp.now();

    // Update the vote record to mark it as max attempts reached
    await db.collection(PENDING_VOTES_COLLECTION).doc(voteDoc.id).update({
      status: "maxAttemptsReached",
      maxAttemptsReachedAt: now,
      finalError: error instanceof Error ? error.message : "Unknown error",
    });

    // Also create a record in critical failures for monitoring
    await db.collection(CRITICAL_FAILURES_COLLECTION).doc(voteDoc.id).set({
      ...voteData,
      status: "maxAttemptsReached",
      maxAttemptsReachedAt: now,
      finalError: error instanceof Error ? error.message : "Unknown error",
    });

    console.log(
      `Vote ${voteDoc.id} marked as max attempts reached and logged to critical failures`
    );
  } catch (updateError) {
    console.error(`Error handling max attempts for vote ${voteDoc.id}:`, updateError);
  }
}

// ---------------------
// HELPER: Recovery function with on-chain verification
// ---------------------
async function recoverVote(
  db: admin.firestore.Firestore,
  voteDoc: admin.firestore.QueryDocumentSnapshot
): Promise<void> {
  const voteData = voteDoc.data() as PendingVoteRecord;
  const voteRef = db.doc(`${PENDING_VOTES_COLLECTION}/${voteDoc.id}`);

  console.log("Processing vote:", voteDoc.id, voteData);

  // Skip completed votes
  if (voteData.status === "completed") {
    console.log("Vote already completed:", voteDoc.id);
    return;
  }

  // Check max attempts
  if (voteData.attempts >= MAX_RECOVERY_ATTEMPTS) {
    console.log(`Vote ${voteDoc.id} has reached max attempts`);
    await handleMaxAttemptsReached(
      db,
      voteDoc,
      voteData,
      new Error("Max recovery attempts reached")
    );
    return;
  }

  try {
    // Update attempt count
    await voteRef.update({
      attempts: admin.firestore.FieldValue.increment(1),
      lastAttempt: admin.firestore.Timestamp.now(),
    });

    // If we have a userOpHash, check its status
    if (voteData.userOpHash) {
      console.log("Checking userOp status for:", voteData.userOpHash);
      const receipt = await checkUserOpReceipt(voteData.userOpHash);

      if (receipt) {
        console.log("Receipt found:", receipt);

        if (receipt.success === true || receipt.success === "true") {
          const transactionHash =
            receipt.receipt?.transactionHash ||
            receipt.transactionHash ||
            receipt.userOpHash;

          // Update status to confirmed with transaction hash
          await voteRef.update({
            status: "confirmed",
            transactionHash,
            lastChecked: admin.firestore.Timestamp.now(),
          });

          // Verify the vote was recorded properly
          const isVerified = await verifyVoteRecorded(
            db,
            voteData.userId,
            voteData.competitionId,
            voteData.prediction,
            transactionHash
          );

          if (isVerified) {
            console.log("Vote verified successfully:", voteDoc.id);
            // Delete the pending vote since it's verified
            await voteRef.delete();
            console.log(`Deleted verified vote ${voteDoc.id} from pending votes`);
          } else {
            console.log("Vote verification failed, attempting recovery:", voteDoc.id);
            await performFirestoreRecovery(db, voteData, transactionHash);
          }
        } else {
          console.log("UserOp failed:", receipt);
          // Mark as failed if the transaction failed
          await voteRef.update({
            status: "failed",
            error: "Transaction failed on-chain",
            failedAt: admin.firestore.Timestamp.now(),
          });
        }
      } else {
        console.log("No receipt found yet for:", voteData.userOpHash);
      }
    }
  } catch (error) {
    console.error(`Recovery attempt failed for vote ${voteDoc.id}:`, error);

    // If this was the last attempt, handle the failure
    if (voteData.attempts >= MAX_RECOVERY_ATTEMPTS - 1) {
      await handleMaxAttemptsReached(db, voteDoc, voteData, error);
    }
  }
}

// ---------------------
// HELPER: Perform Firestore recovery
// ---------------------
async function performFirestoreRecovery(
  db: admin.firestore.Firestore,
  voteData: PendingVoteRecord,
  transactionHash: string
): Promise<void> {
  await db.runTransaction(async (transaction) => {
    console.log("Starting Firestore recovery for vote:", voteData);

    const competitionRef = db.doc(`competitions/${voteData.competitionId}`);
    const competitionDoc = await transaction.get(competitionRef);

    if (!competitionDoc.exists) {
      throw new Error("Competition not found");
    }

    const userVoteRef = db.doc(
      `competitions/${voteData.competitionId}/${
        voteData.prediction === 1 ? "yesVotes" : "noVotes"
      }/${voteData.userId}`
    );

    const userVoteRef2 = db.doc(
      `users/${voteData.userId}/votes/${voteData.competitionId}`
    );

    const leverageMultiplier = voteData.leverageMultiplier || 1;
    console.log("Using leverage multiplier:", leverageMultiplier);

    const voteData2 = {
      userId: voteData.userId,
      timestamp: admin.firestore.Timestamp.now(),
      crowns: 0,
      leverageMultiplier,
      transactionHash,
    };

    // Update vote counts with leverage
    const updateData: any = {};
    if (voteData.prediction === 1) {
      updateData.yesVotes = admin.firestore.FieldValue.increment(leverageMultiplier);
    } else {
      updateData.noVotes = admin.firestore.FieldValue.increment(leverageMultiplier);
    }

    console.log("Updating competition with:", updateData);
    transaction.update(competitionRef, updateData);

    // Set vote records
    console.log("Setting user vote records");
    transaction.set(userVoteRef, voteData2);
    transaction.set(userVoteRef2, {
      yes: voteData.prediction === 1 ? leverageMultiplier : 0,
      no: voteData.prediction === 0 ? leverageMultiplier : 0,
      timestamp: admin.firestore.Timestamp.now(),
      status: "completed",
      transactionHash,
      crowns: 0,
      leverageMultiplier,
    });

    // Update category voters
    const categoryPath = competitionDoc.data()?.category;
    if (categoryPath) {
      const categoryVotersRef = db.doc(
        `categoryVoters/${categoryPath.split("/").join("_")}`
      );
      transaction.set(
        categoryVotersRef,
        {
          voters: admin.firestore.FieldValue.arrayUnion(voteData.userId),
          lastUpdated: admin.firestore.Timestamp.now(),
        },
        { merge: true }
      );
    }
  });
}

// ---------------------
// HELPER: Fetch a single "page" of pending votes
// ---------------------
async function fetchPendingVotesPage(
  db: admin.firestore.Firestore,
  lastDoc: admin.firestore.QueryDocumentSnapshot | null,
  timeoutDuration: number,
  batchSize: number
): Promise<{
  docs: admin.firestore.QueryDocumentSnapshot[];
  lastDoc: admin.firestore.QueryDocumentSnapshot | null;
}> {
  let query = db
    .collection(PENDING_VOTES_COLLECTION)
    .where("status", "in", ["pending", "processing"])
    .where(
      "timestamp",
      "<=",
      admin.firestore.Timestamp.fromMillis(Date.now() - timeoutDuration)
    )
    .orderBy("timestamp", "asc")
    .limit(batchSize);

  if (lastDoc) {
    query = query.startAfter(lastDoc);
  }

  const snapshot = await query.get();
  if (snapshot.empty) {
    return { docs: [], lastDoc: null };
  }

  return {
    docs: snapshot.docs,
    lastDoc: snapshot.docs[snapshot.docs.length - 1],
  };
}

// ---------------------
// MAIN: Monitor Pending Votes (with pagination)
// ---------------------
export const monitorPendingVotes = onSchedule(
  {
    schedule: "every 10 minutes",
    memory: "256MiB",
  },
  async () => {
    const db = admin.firestore();
    const timeoutDuration = 10 * 60 * 1000; // 10 minutes

    let lastDoc: admin.firestore.QueryDocumentSnapshot | null = null;
    let totalProcessed = 0;

    try {
      console.log("Starting vote monitoring with pagination...");
      
      let hasMoreDocs = true;
      while (hasMoreDocs) {
        const { docs, lastDoc: newLastDoc }: {
          docs: admin.firestore.QueryDocumentSnapshot[];
          lastDoc: admin.firestore.QueryDocumentSnapshot | null;
        } = await fetchPendingVotesPage(
          db,
          lastDoc,
          timeoutDuration,
          BATCH_SIZE
        );
        
        lastDoc = newLastDoc;

        if (docs.length === 0) {
          console.log(
            `No more pending votes. Total processed so far: ${totalProcessed}`
          );
          hasMoreDocs = false;
          continue;
        }

        console.log(`Processing a batch of ${docs.length} votes...`);

        const recoveryPromises = docs.map((doc: admin.firestore.QueryDocumentSnapshot) => recoverVote(db, doc));
        await Promise.all(recoveryPromises);

        totalProcessed += docs.length;
        console.log(`Batch processed. Total processed so far: ${totalProcessed}`);

        if (docs.length < BATCH_SIZE) {
          console.log("All matching votes in this run have been processed.");
          hasMoreDocs = false;
        }
      }

      console.log("Completed recovery attempts for all pending votes.");
    } catch (error) {
      console.error("Error in monitorPendingVotes with pagination:", error);
      throw error;
    }
  }
);

// ---------------------
// Cleanup of completed votes
// ---------------------
export const cleanupCompletedVotes = onSchedule(
  {
    schedule: "every 1 hours",
    memory: "256MiB",
  },
  async (event) => {
    const db = admin.firestore();
    const batchSize = 500;

    try {
      console.log("Starting cleanup of completed votes...");

      // Get completed votes that are at least 30 minutes old
      const safetyBuffer = 30 * 60 * 1000; // 30 minutes in milliseconds
      const completedVotes = await db
        .collection(PENDING_VOTES_COLLECTION)
        .where("status", "==", "completed")
        .where(
          "completedAt",
          "<=",
          admin.firestore.Timestamp.fromMillis(Date.now() - safetyBuffer)
        )
        .limit(batchSize)
        .get();

      if (completedVotes.empty) {
        console.log("No completed votes to clean up");
        return;
      }

      console.log(
        `Found ${completedVotes.size} completed votes to verify and clean up`
      );

      const batch = db.batch();
      let batchCount = 0;

      for (const doc of completedVotes.docs) {
        const voteData = doc.data() as PendingVoteRecord;

        // Double-check verification before deletion
        const isVerified = await verifyVoteRecorded(
          db,
          voteData.userId,
          voteData.competitionId,
          voteData.prediction,
          voteData.transactionHash || ""
        );

        if (isVerified) {
          batch.delete(doc.ref);
          batchCount++;
        } else {
          console.warn(
            `Vote ${doc.id} marked as completed but verification failed - keeping record`
          );
          // Mark for investigation
          batch.update(doc.ref, {
            status: "verification_failed",
            verificationFailedAt: admin.firestore.Timestamp.now(),
          });
        }

        // Commit when batch is full
        if (batchCount >= 500) {
          await batch.commit();
          console.log(`Committed batch of ${batchCount} deletions`);
          batchCount = 0;
        }
      }

      // Commit any remaining operations
      if (batchCount > 0) {
        await batch.commit();
        console.log(`Committed final batch of ${batchCount} operations`);
      }

      console.log("Completed cleanup of verified votes");
    } catch (error) {
      console.error("Error in cleanupCompletedVotes:", error);
      throw error;
    }
  }
);

// ---------------------
// Cleanup of old maxAttemptsReached votes
// ---------------------
export const cleanupMaxAttemptsVotes = onSchedule(
  {
    schedule: "every 24 hours",
    memory: "256MiB",
  },
  async (event) => {
    const db = admin.firestore();
    const retentionPeriod = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

    try {
      console.log("Starting cleanup of old maxAttemptsReached votes...");

      // Get votes that reached max attempts more than 7 days ago
      const oldVotes = await db
        .collection(PENDING_VOTES_COLLECTION)
        .where("status", "==", "maxAttemptsReached")
        .where(
          "maxAttemptsReachedAt",
          "<=",
          admin.firestore.Timestamp.fromMillis(Date.now() - retentionPeriod)
        )
        .limit(BATCH_SIZE)
        .get();

      if (oldVotes.empty) {
        console.log("No old votes to clean up");
        return;
      }

      console.log(`Found ${oldVotes.size} old votes to clean up`);

      // Delete votes in batches
      const batch = db.batch();
      let batchCount = 0;

      for (const doc of oldVotes.docs) {
        batch.delete(doc.ref);
        batchCount++;

        // Commit when batch is full
        if (batchCount >= 500) {
          await batch.commit();
          console.log(`Committed batch of ${batchCount} deletions`);
          batchCount = 0;
        }
      }

      // Commit any remaining deletions
      if (batchCount > 0) {
        await batch.commit();
        console.log(`Committed final batch of ${batchCount} deletions`);
      }

      console.log("Completed cleanup of old maxAttemptsReached votes");
    } catch (error) {
      console.error("Error in cleanupMaxAttemptsVotes:", error);
      throw error;
    }
  }
);



=== File: ../../branch/app-brkt-v2/functions/src/notifications.ts ===
import * as functions from "firebase-functions/v2";
import * as admin from "firebase-admin";
import { FirestoreEvent, Change } from "firebase-functions/v2/firestore";
import { QueryDocumentSnapshot } from "firebase-admin/firestore";
import { HttpsError } from "firebase-functions/v2/https";
import { CallableRequest } from "firebase-functions/v2/https";

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();
const messaging = admin.messaging();

// Constants
const BATCH_SIZE = 500;           // Max batch size for Firestore writes/deletes
const MAX_MULTICAST_SIZE = 500;   // FCM max tokens per sendEachForMulticast
const MAX_IN_QUERY = 10;          // Firestore "IN" operator limit

interface FeaturedMarketData {
  competitionId: string;
  title: string;
  category: string;
  image: string;
  tags: string[];
  featured: boolean;
}

// -----------------------------------------------------------------------
// 1. HELPER FUNCTIONS FOR BATCHED "IN" QUERIES
// -----------------------------------------------------------------------

/**
 * Chunk an array into sub-arrays of size up to `maxSize`.
 */
function chunkArray<T>(array: T[], maxSize: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += maxSize) {
    chunks.push(array.slice(i, i + maxSize));
  }
  return chunks;
}

/**
 * Fetch user documents in batches of up to 10 user IDs per "in" query.
 */
async function getUserDocsInBatches(userIds: string[]): Promise<admin.firestore.QueryDocumentSnapshot[]> {
  const allUserDocs: admin.firestore.QueryDocumentSnapshot[] = [];
  const idChunks = chunkArray(userIds, MAX_IN_QUERY);

  for (const chunk of idChunks) {
    const snap = await db
      .collection("users")
      .where(admin.firestore.FieldPath.documentId(), "in", chunk)
      .get();
    allUserDocs.push(...snap.docs);
  }

  return allUserDocs;
}

/**
 * Fetch tokens in batches, using "in" queries for userId up to 10 at a time.
 */
async function getTokenDocsInBatches(userIds: string[]): Promise<admin.firestore.QueryDocumentSnapshot[]> {
  const allTokenDocs: admin.firestore.QueryDocumentSnapshot[] = [];
  const idChunks = chunkArray(userIds, MAX_IN_QUERY);

  for (const chunk of idChunks) {
    const snap = await db
      .collectionGroup("tokens")
      .where("userId", "in", chunk)
      .get();
    allTokenDocs.push(...snap.docs);
  }

  return allTokenDocs;
}

/**
 * Fetch the "notifications" doc in the "settings" sub-collection
 * for the given doc path arrays in chunks.
 *
 * Since your doc path is /users/{userId}/settings/notifications,
 * we can build the doc ID as `users/${userId}/settings/notifications`
 * and query by documentId in the "settings" collectionGroup.
 */
async function getSettingsDocsInBatches(docPaths: string[]): Promise<admin.firestore.QueryDocumentSnapshot[]> {
  const allSettingsDocs: admin.firestore.QueryDocumentSnapshot[] = [];
  const pathChunks = chunkArray(docPaths, MAX_IN_QUERY);

  for (const chunk of pathChunks) {
    const snap = await db
      .collection("settings") // collectionGroup on "settings" sub-collections
      .where(admin.firestore.FieldPath.documentId(), "in", chunk)
      .get();
    allSettingsDocs.push(...snap.docs);
  }

  return allSettingsDocs;
}

// -----------------------------------------------------------------------
// 2. MARKET RESOLUTION NOTIFICATIONS
// -----------------------------------------------------------------------

export const onMarketResolution = functions.firestore.onDocumentUpdated(
  "competitions/{competitionId}",
  async (event: FirestoreEvent<Change<QueryDocumentSnapshot> | undefined>) => {
    if (!event.data) return;

    const newData = event.data.after.data();
    const previousData = event.data.before.data();
    if (!newData || !previousData) return;

    // Only trigger if status changes to "resolved"
    if (newData.status === "resolved" && previousData.status !== "resolved") {
      const competitionId = event.params.competitionId;

      try {
        // 1) Get all votes for this competition
        const votesSnapshot = await db
          .collectionGroup("votes")
          .where("competitionId", "==", competitionId)
          .get();

        // 2) Group votes by user ID
        const userVotes = new Map<string, { yes: boolean; no: boolean }>();
        votesSnapshot.docs.forEach((doc) => {
          const userId = doc.ref.parent.parent?.id; // /users/{userId}/votes/{voteId}
          if (!userId) return;
          const vote = doc.data();
          userVotes.set(userId, { yes: vote.yes, no: vote.no });
        });

        if (userVotes.size === 0) return;

        // 3) Get user "notifications" docs in "settings" collection for these users
        //    doc path is "users/{userId}/settings/notifications"
        const docPaths = Array.from(userVotes.keys()).map(
          (id) => `users/${id}/settings/notifications`
        );
        const prefsSnapshot = await getSettingsDocsInBatches(docPaths);

        // 4) Get tokens for these users
        const userIds = Array.from(userVotes.keys());
        const tokensSnapshot = await getTokenDocsInBatches(userIds);

        // 5) Group tokens by user
        const userTokens = new Map<string, string[]>();
        tokensSnapshot.forEach((doc) => {
          const data = doc.data();
          const userId = data.userId;
          const token = data.token;
          if (userId && token) {
            const tokens = userTokens.get(userId) || [];
            tokens.push(token);
            userTokens.set(userId, tokens);
          }
        });

        // 6) Build notifications for each user
        const notificationBatches: {
          message: admin.messaging.MulticastMessage;
          userId: string;
        }[] = [];
        const invalidTokens = new Map<string, Set<string>>();

        for (const [userId, vote] of userVotes.entries()) {
          // Find this user's "notifications" doc
          const userDoc = prefsSnapshot.find((doc) => doc.id === `users/${userId}/settings/notifications`);
          if (!userDoc) continue;

          const userPrefs = userDoc.data()?.preferences;
          if (!userPrefs?.winnerNotifications) continue;

          const tokens = userTokens.get(userId);
          if (!tokens?.length) continue;

          const votedCorrectly =
            (vote.yes && newData.resolution === "yes") ||
            (vote.no && newData.resolution === "no");

          // Split tokens into chunks of 500 for FCM
          const tokenChunks = chunkArray(tokens, MAX_MULTICAST_SIZE);

          tokenChunks.forEach((chunk) => {
            notificationBatches.push({
              message: {
                notification: {
                  title: votedCorrectly
                    ? "Congratulations! You won! ðŸŽ‰"
                    : "Market Resolved",
                  body: votedCorrectly
                    ? `You correctly predicted "${newData.title}"! Claim your rewards now.`
                    : `The market "${newData.title}" has been resolved.`,
                },
                data: {
                  type: votedCorrectly ? "winner" : "market_resolution",
                  competitionId,
                  url: `/competition/${competitionId}`,
                },
                tokens: chunk,
              },
              userId,
            });
          });
        }

        // 7) Send notifications in parallel
        const results = await Promise.allSettled(
          notificationBatches.map(async (batch) => {
            try {
              const response = await messaging.sendEachForMulticast(batch.message);
              // Track invalid tokens
              response.responses.forEach((resp, idx) => {
                if (!resp.success && batch.message.tokens[idx]) {
                  const badTokenSet = invalidTokens.get(batch.userId) || new Set<string>();
                  badTokenSet.add(batch.message.tokens[idx]);
                  invalidTokens.set(batch.userId, badTokenSet);
                }
              });
              return response;
            } catch (error: unknown) {
              console.error("Error sending notification batch:", error);
              return null;
            }
          })
        );

        // 8) Clean up invalid tokens
        if (invalidTokens.size > 0) {
          let operationCount = 0;
          let batch = db.batch();

          for (const [userId, tokens] of invalidTokens.entries()) {
            for (const token of tokens) {
              batch.delete(db.doc(`users/${userId}/tokens/${token}`));
              operationCount++;
              if (operationCount >= BATCH_SIZE) {
                await batch.commit();
                batch = db.batch();
                operationCount = 0;
              }
            }
          }

          if (operationCount > 0) {
            await batch.commit();
          }
        }

        console.log("Market resolution notifications completed:", {
          totalUsers: userVotes.size,
          notificationsSent: results.length,
          successful: results.filter((r) => r && r.status === "fulfilled").length,
        });
      } catch (error: unknown) {
        console.error("Error processing market resolution:", error);
      }
    }
  }
);

// -----------------------------------------------------------------------
// 3. NEW FEATURED MARKET NOTIFICATIONS
// -----------------------------------------------------------------------

export const onNewFeaturedMarket = functions.firestore.onDocumentCreated(
  "competitions/{competitionId}",
  async (event: FirestoreEvent<QueryDocumentSnapshot | undefined>) => {
    if (!event.data) return;

    const marketData = event.data.data() as FeaturedMarketData;
    const competitionId = event.params.competitionId;

    // Only send notifications if "featured" is true
    if (!marketData.featured) return;

    try {
      // 1) Get all "notifications" docs in the "settings" sub-collection
      //    where preferences.newMarkets == true
      //    The doc name is "notifications" inside "settings" for each user.
      //
      //    We can do a collectionGroup("settings") with a simple where:
      //    .where("preferences.newMarkets", "==", true)
      //
      //    That returns all docs in all sub-collections named "settings"
      //    that have preferences.newMarkets == true
      const userPrefsSnapshot = await db
        .collectionGroup("settings")
        .where("preferences.newMarkets", "==", true)
        .get();

      if (userPrefsSnapshot.empty) {
        console.log("No users have newMarkets enabled.");
        return;
      }

      // 2) From these docs, get user IDs
      //    doc.ref.parent.parent = user doc
      const userIds = userPrefsSnapshot.docs
        .map((doc) => doc.ref.parent.parent?.id)
        .filter(Boolean) as string[];

      if (!userIds.length) return;

      // 3) Fetch the actual "users" documents in batches (to get categories, etc.)
      const usersSnapshotDocs = await getUserDocsInBatches(userIds);

      // 4) Fetch all tokens for these users in batches
      const tokensSnapshotDocs = await getTokenDocsInBatches(userIds);

      // 5) Determine which users are interested in this market
      //    We'll store user ID => tokens
      const eligibleUsers = new Map<string, string[]>();

      // Build a quick map of userId => categories array
      const userCategoriesMap = new Map<string, string[]>();
      usersSnapshotDocs.forEach((doc) => {
        const userData = doc.data();
        const categories: string[] = userData.categories || [];
        userCategoriesMap.set(doc.id, categories);
      });

      const marketCategory = marketData.category.toLowerCase().trim();
      const marketTags = new Set(
        (marketData.tags || []).map((t) => t.toLowerCase().trim())
      );

      // 6) Figure out which users have overlapping category/tags
      for (const doc of usersSnapshotDocs) {
        const userId = doc.id;
        const categories = userCategoriesMap.get(userId) || [];
        const userCategoriesSet = new Set(
          categories.map((cat) => cat.toLowerCase().trim())
        );

        // Check if user categories includes the marketCategory or any marketTags
        const isInterestedInCategory =
          userCategoriesSet.has(marketCategory) ||
          [...marketTags].some((tag) => userCategoriesSet.has(tag));

        if (isInterestedInCategory) {
          eligibleUsers.set(userId, []);
        }
      }

      // 7) Group tokens by user (only for those in eligibleUsers)
      tokensSnapshotDocs.forEach((doc) => {
        const data = doc.data();
        const userId = data.userId;
        const token = data.token;
        if (userId && token && eligibleUsers.has(userId)) {
          const arr = eligibleUsers.get(userId) || [];
          arr.push(token);
          eligibleUsers.set(userId, arr);
        }
      });

      if (eligibleUsers.size === 0) {
        console.log("No users are interested in this market's category/tags.");
        return;
      }

      // 8) Build and send notifications in batches
      const notificationBatches: {
        message: admin.messaging.MulticastMessage;
        userId: string;
      }[] = [];

      for (const [userId, tokens] of eligibleUsers.entries()) {
        if (!tokens.length) continue;

        // Split tokens into chunks of 500 for FCM
        const tokenChunks = chunkArray(tokens, MAX_MULTICAST_SIZE);
        for (const chunk of tokenChunks) {
          notificationBatches.push({
            message: {
              notification: {
                title: "New Featured Market! ðŸŒŸ",
                body: `${marketData.title} - Predict now in ${marketData.category}`,
              },
              data: {
                type: "new_market",
                competitionId,
                url: `/competition/${competitionId}`,
                category: marketData.category,
                featured: "true",
              },
              tokens: chunk,
            },
            userId,
          });
        }
      }

      // 9) Send notifications in parallel
      const results = await Promise.allSettled(
        notificationBatches.map(async (batch) => {
          try {
            const response = await messaging.sendEachForMulticast(batch.message);

            // Log results
            await db.collection("notificationLogs").add({
              type: "new_featured_market",
              userId: batch.userId,
              competitionId,
              marketTitle: marketData.title,
              timestamp: admin.firestore.FieldValue.serverTimestamp(),
              success: response.successCount > 0,
              tokensCount: batch.message.tokens.length,
              successCount: response.successCount,
              failureCount: response.failureCount,
            });

            // Clean up invalid tokens
            if (response.failureCount > 0) {
              const invalidTokens = response.responses
                .map((resp, idx) => (!resp.success ? batch.message.tokens[idx] : null))
                .filter(Boolean) as string[];

              if (invalidTokens.length > 0) {
                const cleanupBatch = db.batch();
                invalidTokens.forEach((t) => {
                  cleanupBatch.delete(db.doc(`users/${batch.userId}/tokens/${t}`));
                });
                await cleanupBatch.commit();
              }
            }

            return response;
          } catch (error: unknown) {
            console.error("Error sending notification batch:", error);
            return null;
          }
        })
      );

      console.log("Featured market notifications completed:", {
        eligibleUsers: eligibleUsers.size,
        notificationsSent: results.length,
        successful: results.filter((r) => r && r.status === "fulfilled").length,
      });
    } catch (error: unknown) {
      console.error("Error in onNewFeaturedMarket:", error);
      throw new HttpsError("internal", "Notification processing failed");
    }
  }
);

// -----------------------------------------------------------------------
// 4. TEST NOTIFICATION (onCall)
// -----------------------------------------------------------------------

export const sendTestNotification = functions.https.onCall(
  async (request: CallableRequest) => {
    if (!request.auth) {
      throw new HttpsError("unauthenticated", "Must be authenticated");
    }
    const userId = request.auth.uid;

    try {
      // Grab all tokens from this user
      const tokensSnapshot = await db.collection(`users/${userId}/tokens`).get();
      const tokens = tokensSnapshot.docs
        .map((doc) => doc.data().token as string)
        .filter(Boolean);

      if (tokens.length === 0) {
        throw new HttpsError("failed-precondition", "No FCM tokens found");
      }

      // Build a test message
      const message: admin.messaging.MulticastMessage = {
        notification: {
          title: "Test FCM Notification ðŸ””",
          body: "This is a test notification sent through Firebase Cloud Messaging",
        },
        data: {
          type: "test",
          timestamp: Date.now().toString(),
        },
        // Send to the first 500 tokens only (just in case)
        tokens: tokens.slice(0, MAX_MULTICAST_SIZE),
      };

      // Send the message
      const response = await messaging.sendEachForMulticast(message);

      // Clean up invalid tokens
      if (response.failureCount > 0) {
        const batch = db.batch();
        response.responses.forEach((resp, idx) => {
          if (!resp.success && tokens[idx]) {
            batch.delete(db.doc(`users/${userId}/tokens/${tokens[idx]}`));
          }
        });
        await batch.commit();
      }

      return {
        success: true,
        tokensCount: tokens.length,
        successCount: response.successCount,
        failureCount: response.failureCount,
      };
    } catch (error: unknown) {
      console.error("Error sending test notification:", error);
      throw new HttpsError("internal", "Failed to send test notification");
    }
  }
);



=== Directory: ../../branch/app-brkt-v2/src ===


=== File: ../../branch/app-brkt-v2/src/types.ts ===
import { User as FirebaseUser } from "firebase/auth";

export interface ExtendedUser {
  uid: string;
  email: string;
  emailVerified: boolean;
  isAnonymous: boolean;
  metadata: {
    creationTime?: string;
    lastSignInTime?: string;
  };
  providerData: Array<{
    providerId: string;
    uid: string;
    displayName: string | null;
    email: string | null;
    phoneNumber: string | null;
    photoURL: string | null;
  }>;
  username: string;
  credits: number;
  photoURL: string | null;
  biconomyAddress?: string;
  hasSmartAccount?: boolean;
  playMode?: boolean; 
}

export interface ClaimsState {
  pendingClaimsCount: number;
  totalClaimableAmount: number;
  isUSDC: boolean;
  loading: boolean;
  lastFetchedAt: number | null;
  error: string | null;
}


export interface BiconomyUser {
  biconomyAddress?: string;
  hasSmartAccount?: boolean;
}

export interface ActivityItem {
  id: string;
  title: string;
  image: string;
  vote: "yes" | "no";
  timeAgo: string;
  timestamp: string;
  earnings: number;
  status: string;
  crowns: number;
  category: string;
  tags: string[];
  endDate: string;
  totalVotes: number;
  totalCrowns: number;
  competitionAddress?: string;
  isClaimable?: boolean;
  isClaiming?: boolean;
  crownsCost?: number;
}


export interface ProfileProps {
  user: {
    username: string;
    avatar: string;
    following: number;
    description: string;
    followers: number;
    credits: number;
    bets: number;
    winPercentage: number;
    activity: ActivityItem[];
    categories?: string[];
    walletAddress?:string;
    biconomyAddress?: string;
    playMode?: boolean;
  };
}

export interface FollowUser {
  username: string;
  avatar: string;
  uid: string | null; 
  followed: boolean;
  description: string;
  following: number;
  followers: number;
  bets: number;
  winPercentage: number;
  activity: ActivityItem[];
}

export interface Vote {
  id: string;
  timestamp: Date;
  yes: boolean;
  no: boolean;
  crowns: number;
}

export interface Competition {
  id: string;
  title: string;
  image: string;
  yesVotes: number;
  noVotes: number;
  status: string;
  category: string;
  tags: string[];
  endDate: Date;
  totalCrowns: number;
}

export interface ReferralEntry {
  userId: string;
  username: string;
  avatar: string;
  referralCount: number;
  totalPnl: number;
}

export interface ReferralLeaderboardState {
  entries: ReferralEntry[];
  status: "idle" | "loading" | "succeeded" | "failed";
  error: string | null;
}



=== Directory: ../../branch/app-brkt-v2/src/ABI ===


=== File: ../../branch/app-brkt-v2/src/ABI/BracketABI.json ===
[{"inputs":[{"internalType":"address","name":"_competitionFactory","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"CompetitionCompleted","type":"error"},{"inputs":[],"name":"CompetitionHasExpired","type":"error"},{"inputs":[],"name":"CompetitionIsLive","type":"error"},{"inputs":[],"name":"CompetitionNotCompleted","type":"error"},{"inputs":[],"name":"CompetitionNotExpired","type":"error"},{"inputs":[],"name":"CompetitionNotLive","type":"error"},{"inputs":[],"name":"CompetitionStillInProgress","type":"error"},{"inputs":[],"name":"IncorrectRegistrationFeePaid","type":"error"},{"inputs":[],"name":"IncorrectRegistrationToken","type":"error"},{"inputs":[{"internalType":"uint256","name":"_expectedLength","type":"uint256"},{"internalType":"uint256","name":"_actualLength","type":"uint256"}],"name":"InvalidCompetitionPredictionLength","type":"error"},{"inputs":[{"internalType":"uint256","name":"expectedLength","type":"uint256"},{"internalType":"uint256","name":"actualLength","type":"uint256"}],"name":"InvalidCompetitionResultsLength","type":"error"},{"inputs":[],"name":"InvalidExpiration","type":"error"},{"inputs":[{"internalType":"uint256","name":"matchId","type":"uint256"}],"name":"InvalidMatchId","type":"error"},{"inputs":[{"internalType":"uint256","name":"numTeams","type":"uint256"}],"name":"InvalidNumberOfTeams","type":"error"},{"inputs":[],"name":"InvalidRegistrationFeeInfo","type":"error"},{"inputs":[],"name":"InvalidStartTime","type":"error"},{"inputs":[{"internalType":"uint256","name":"matchId","type":"uint256"}],"name":"MatchAlreadyCompleted","type":"error"},{"inputs":[{"internalType":"uint256","name":"matchId","type":"uint256"}],"name":"MatchNotCompleted","type":"error"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"NoPendingRewards","type":"error"},{"inputs":[],"name":"NoProtocolFeesCaptured","type":"error"},{"inputs":[],"name":"NoRegistrationFee","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"NotFactory","type":"error"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"PRBMath_MulDiv18_Overflow","type":"error"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"},{"internalType":"uint256","name":"denominator","type":"uint256"}],"name":"PRBMath_MulDiv_Overflow","type":"error"},{"inputs":[],"name":"RoundAlreadyAtEnd","type":"error"},{"inputs":[],"name":"SafeTransferEthFailed","type":"error"},{"inputs":[{"internalType":"uint256","name":"numTeams","type":"uint256"},{"internalType":"uint256","name":"numTeamNames","type":"uint256"}],"name":"TeamNamesMismatch","type":"error"},{"inputs":[{"internalType":"uint256","name":"numTeams","type":"uint256"}],"name":"TooManyTeams","type":"error"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"UserNotRegistered","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"BracketPredictionSaved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"_matchId","type":"uint256"},{"indexed":true,"internalType":"uint8","name":"_winningTeamId","type":"uint8"}],"name":"MatchCompleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"_owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"ProtocolFeesClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"UserClaimedRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"components":[{"internalType":"bool","name":"isNetworkToken","type":"bool"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint256","name":"fee","type":"uint256"}],"indexed":false,"internalType":"struct RegistrationFeeInfo","name":"feeInfo","type":"tuple"}],"name":"UserIncreasedBracketPrediction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"components":[{"internalType":"bool","name":"isNetworkToken","type":"bool"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint256","name":"fee","type":"uint256"}],"indexed":false,"internalType":"struct RegistrationFeeInfo","name":"feeInfo","type":"tuple"}],"name":"UserPaidForBracketPrediction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"UserRefundedForBracket","type":"event"},{"inputs":[],"name":"MAX_TEAMS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"advanceRound","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint8[]","name":"_matchResults","type":"uint8[]"}],"name":"advanceRound","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"bannerURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"calculatePendingRewards","outputs":[{"internalType":"uint256","name":"pendingRewards_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"calculateProtocolFeeCaptured","outputs":[{"internalType":"uint256","name":"protocolFeeCaptured_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimProtocolFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"competitionFactory","outputs":[{"internalType":"contract ICompetitionFactory","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"competitionName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_matchId","type":"uint256"},{"internalType":"uint8","name":"_winningTeamId","type":"uint8"}],"name":"completeMatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_registrant","type":"address"},{"internalType":"uint8[]","name":"_matchPredictions","type":"uint8[]"}],"name":"createBracketPrediction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_registrant","type":"address"},{"internalType":"uint8[]","name":"_matchPredictions","type":"uint8[]"}],"name":"createBracketPredictionGasToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"expirationEpoch","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBracketPredictionFeeInfo","outputs":[{"components":[{"internalType":"bool","name":"isNetworkToken","type":"bool"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint256","name":"fee","type":"uint256"}],"internalType":"struct RegistrationFeeInfo","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCompetitionProgression","outputs":[{"components":[{"internalType":"uint8","name":"winningTeamId","type":"uint8"},{"internalType":"bool","name":"isCompleted","type":"bool"}],"internalType":"struct MatchOutcome[]","name":"bracketProgress_","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_matchId","type":"uint256"}],"name":"getMatchOutcome","outputs":[{"components":[{"internalType":"uint8","name":"winningTeamId","type":"uint8"},{"internalType":"bool","name":"isCompleted","type":"bool"}],"internalType":"struct MatchOutcome","name":"matchOutcome_","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTeamNames","outputs":[{"internalType":"string[]","name":"teamNames_","type":"string[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalScore","outputs":[{"internalType":"uint256","name":"totalScore_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getUserBracketPrediction","outputs":[{"internalType":"uint8[]","name":"bracketPrediction_","type":"uint8[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getUserBracketScore","outputs":[{"internalType":"uint256","name":"score_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getUserPaymentMultiplier","outputs":[{"internalType":"UD60x18","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getUserScorePercent","outputs":[{"internalType":"uint256","name":"scorePercent_","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasFinished","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasStarted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"hasUserRegistered","outputs":[{"internalType":"bool","name":"isRegistered_","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_registrant","type":"address"}],"name":"increasePredictionPaymentMultiplier","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_registrant","type":"address"}],"name":"increasePredictionPaymentMultiplierGasToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_competitionOwner","type":"address"},{"internalType":"string","name":"_competitionName","type":"string"},{"internalType":"uint16","name":"_numTeams","type":"uint16"},{"internalType":"uint64","name":"_startingEpoch","type":"uint64"},{"internalType":"uint64","name":"_expirationEpoch","type":"uint64"},{"internalType":"string[]","name":"_teamNames","type":"string[]"},{"internalType":"string","name":"_bannerURI","type":"string"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_competitionOwner","type":"address"},{"internalType":"string","name":"_competitionName","type":"string"},{"internalType":"uint16","name":"_numTeams","type":"uint16"},{"internalType":"uint64","name":"_startingEpoch","type":"uint64"},{"internalType":"uint64","name":"_expirationEpoch","type":"uint64"},{"internalType":"string[]","name":"_teamNames","type":"string[]"},{"internalType":"string","name":"_bannerURI","type":"string"},{"internalType":"uint16","name":"_totalPointsPerRound","type":"uint16"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_competitionOwner","type":"address"},{"internalType":"string","name":"_competitionName","type":"string"},{"internalType":"uint16","name":"_numTeams","type":"uint16"},{"internalType":"uint64","name":"_startingEpoch","type":"uint64"},{"internalType":"uint64","name":"_expirationEpoch","type":"uint64"},{"internalType":"string[]","name":"_teamNames","type":"string[]"},{"internalType":"string","name":"_bannerURI","type":"string"},{"internalType":"uint16","name":"_totalPointsPerRound","type":"uint16"},{"components":[{"internalType":"bool","name":"isNetworkToken","type":"bool"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint256","name":"fee","type":"uint256"}],"internalType":"struct RegistrationFeeInfo","name":"_registrationFeeInfo","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"numTeams","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"refundRegistrationFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"roundsRemaining","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string[]","name":"_names","type":"string[]"}],"name":"setTeamNames","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"start","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"startingEpoch","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"teamNames","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalPointsAvailable","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalPointsPerRound","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalRegistrationReserves","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalRounds","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]


=== File: ../../branch/app-brkt-v2/src/ABI/FactoryABI.json ===


=== File: ../../branch/app-brkt-v2/.eslintrc.json ===
{
  "extends": "next/core-web-vitals"
}



=== File: ../../branch/app-brkt-v2/.firebaserc ===
{
  "projects": {
    "default": "brkt-app"
  }
}



=== File: ../../branch/app-brkt-v2/README.md ===
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.



=== File: ../../branch/app-brkt-v2/components.json ===
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}



=== File: ../../branch/app-brkt-v2/firebase.json ===
{
  "firestore": {
    "indexes": "firestore.indexes.json"
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint",
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ]
}


=== File: ../../branch/app-brkt-v2/firebase.ts ===
